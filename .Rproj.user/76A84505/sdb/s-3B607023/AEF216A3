{
    "collab_server" : "",
    "contents" : "closest <- function (SAPCA, \n                     sequence, \n                     PC = 1:3,\n                     n  = 10){\n  \n  coords     <- SAPCA$seq.space.PCA$coordinates\n  centre     <- coords[sequence,PC]\n  centre.m   <- matrix(rep(centre,nrow(coords)),\n                       nrow  = nrow(coords),\n                       byrow = TRUE)\n  distances  <- SAPCA$seq.space.PCA$coordinates[,PC]-centre.m\n  rootsquare <- sqrt(rowSums(distances^2))\n  \n  sorted     <- as.matrix(rootsquare[order(rootsquare)])\n  colnames(sorted) <- \"distance\"\n  \n  head(sorted,n)\n}\n  \n\n\nas.fasta <- function(matrix,degap=FALSE,decolgap=FALSE,write=FALSE,name=NULL){\n  \n  # Remove empty columns\n  if(decolgap){\n    matrix<-matrix[,colMeans(matrix==\"-\")!=1]\n  }\n  \n  # Convert alignment matrix to list of strings\n  names <- paste(\">\",row.names(matrix),sep=\"\")\n  seqs  <- do.call(\"paste\",c(data.frame(matrix),sep=\"\"))\n\n  # If just one sequence, this is how to name it\n  if(is.null(dim(matrix))){\n    names <- \">sequence\"\n    if(!is.null(name)){\n      names <- paste(\">\",name,sep=\"\")\n    }\n    seqs  <- paste(matrix,collapse=\"\")\n  }\n  \n  # Degap sequences\n  if (degap){\n    seqs <- gsub(\"-\",\"\",seqs)\n  }\n  \n  # Interleave names and sequences\n  ord1 <- 2*(1:length(names))-1\n  ord2 <- 2*(1:length(seqs))\n  \n  # Output\n  if (write==FALSE){\n    cat(c(names,seqs)[order(c(ord1,ord2))], sep = \"\\n\")\n  }else{\n    if (!grepl(\".fa\",write,ignore.case=TRUE)){\n      write<-paste(write,\".fa\",sep=\"\")\n    }\n    cat(c(names,seqs)[order(c(ord1,ord2))], sep = \"\\n\", file = write)\n  }\n}\n\n\n\nas.AAstring<-function(string, degap=FALSE){\n  string <- paste(string,collapse=\"\")\n  if(degap==TRUE){\n    string<-gsub(\"-\",\"\",string)\n  }\n  output <- Biostrings::AAString(string)\n  output\n}\n\n\nas.AAstringSet<-function(MSA, degap=FALSE){\n  MSA <- apply(MSA,1,paste,collapse=\"\")\n  if(degap==TRUE){\n    MSA<-gsub(\"-\",\"\",MSA)\n  }\n  output <- Biostrings::AAStringSet(MSA)\n  output\n}\n\n\n\nseq.MSA.add <- function(SAPCA,sequence,SAPCAname=NULL){\n  MSA   <- SAPCA$numerical.alignment$MSA\n  MSA2  <- as.AAstringSet(MSA,degap = TRUE)\n  seqs  <- nrow(MSA)\n  seq   <- as.AAstring(sequence, degap=FALSE)\n  seq.d <- as.AAstring(sequence, degap=TRUE)\n  BLOSUM40 <- blosum()\n  \n  aln.all <- Biostrings::pairwiseAlignment(MSA2,\n                                           seq.d,\n                                           substitutionMatrix = BLOSUM40,\n                                           gapOpening   = 0, \n                                           gapExtension = 8,\n                                           scoreOnly    = TRUE)\n  \n  # Max possible similarity score\n  aln.limit <- Biostrings::pairwiseAlignment(seq.d,\n                                             seq.d,\n                                             substitutionMatrix = BLOSUM40,\n                                             gapOpening   = 0, \n                                             gapExtension = 8,\n                                             scoreOnly    = TRUE)\n  \n  # Similarity score as percentage of max\n  aln.hit.score <- max(aln.all)/aln.limit\n  \n  # The sequence of the best matching member of the database\n  aln.hit.num  <- which(aln.all==max(aln.all))[1]\n  aln.hit.name <- SAPCA$numerical.alignment$seq.names[aln.hit.num]\n  aln.hit.seq  <- paste(as.AAstring(MSA[aln.hit.num,],degap = 1))\n  \n  # Use \"*\" to indicate gaps in the best reference sequence (aln.hit) \n  aln.hit <- gsub(\"-\",\"*\",as.AAstring(MSA[aln.hit.num,]))\n  aln.add <- Biostrings::pairwiseAlignment(aln.hit,\n                                           seq.d,\n                                           substitutionMatrix = BLOSUM40,\n                                           gapOpening   = 0, \n                                           gapExtension = 8)\n  \n  # Has the new sequence introduced exrta gaps into the hit sequence alignement?\n  aln.hit.orig         <- as.AAstring(MSA[aln.hit.num,])\n  aln.hit.new          <- Biostrings::pattern(aln.add)\n  aln.hit.seq.aln.orig <- unlist(strsplit(as.character(aln.hit.orig),\"\"))\n  aln.hit.seq.aln.new  <- unlist(strsplit(as.character(aln.hit.new),\"\"))\n  \n  if(as.character(aln.hit.orig)!=as.character(aln.hit.new)){\n    print(paste(sum(aln.hit.seq.aln.new==\"-\"),\n                \"residues of the new sequence were not alignable to the\",\n                SAPCAname,\n                \"reference MSA so were ignored\"))\n  }\n  \n  # Alignment addition as matrix\n  aln.add.mat <- rbind(unlist(strsplit(as.character(Biostrings::pattern(aln.add)),\"\")),\n                       unlist(strsplit(as.character(Biostrings::subject(aln.add)),\"\")))\n\n  # Unmathcable resiues removed from aligned sequence\n  aln.add2 <- aln.add.mat[2,][aln.add.mat[1,]!=\"-\"]\n  aln.add3 <- paste(as.AAstring(aln.add2))\n\n  # Gaps in the hit sequence (original and newly aligned)\n  gaps.orig       <- unlist(strsplit(as.character(aln.hit.orig),\"[A-Z]\"))\n  gaps.count.orig <- nchar(gaps.orig)\n  gaps.lead.orig  <- gaps.count.orig[1]\n  gaps.trail.orig <- gaps.count.orig[length(gaps.count.orig)]\n  \n  gaps.new        <- unlist(strsplit(as.character(gsub(\"-\",\"\",aln.hit.new)),\"[A-Z]\"))\n  gaps.count.new  <- nchar(gaps.new)\n  gaps.lead.new   <- gaps.count.new[1]\n  gaps.trail.new  <- gaps.count.new[length(gaps.count.new)]\n  \n  if(length(gaps.count.orig)>length(gaps.count.new)){\n    gaps.count.new <- append(gaps.count.new,0)\n  }\n  \n  gaps.discrep     <- suppressWarnings(rbind(gaps.count.orig,gaps.count.new))\n  gaps.discrep.num <- gaps.discrep[1,]-gaps.discrep[2,]\n  gaps.lead.add    <- gaps.discrep.num[1]\n  gaps.trail.add   <- gaps.discrep.num[length(gaps.discrep.num)]\n  \n  # New alignment  \n  aln.add4  <- c(rep(\"-\",gaps.lead.add),\n                 aln.add2,\n                 rep(\"-\",gaps.trail.add))\n  \n  seq.alignable <- Biostrings::pairwiseAlignment(seq.d,\n                                                 as.AAstring(aln.add3, degap=TRUE),\n                                                 substitutionMatrix = BLOSUM40,\n                                                 gapOpening   = 0, \n                                                 gapExtension = 8)\n  length(aln.add4)==ncol(MSA)\n  \n  query     <- aln.add4\n  \n  aln.final <- rbind(query,MSA)\n  output    <- list(MSA             = aln.final,\n                    aln.hit.name    = aln.hit.name,\n                    aln.hit.seq     = aln.hit.seq,\n                    aln.hit.score   = aln.hit.score,\n                    aln.all.score   = aln.all/aln.limit,\n                    seq.unalignable = seq.alignable)\n  output\n}\n\n\n\nseq.rotate <- function(SAPCA,newseq){\n  \n  res.props  <- colnames(SAPCA$numerical.alignment$res.prop)\n  prop.means <- SAPCA$numerical.alignment$prop.means\n  prop.vars  <- SAPCA$numerical.alignment$prop.vars\n  # Align new sequence with MSA\n  \n  # Numericise new sequence\n  newseq.num <- numericise_MSA(MSA      = newseq$MSA[c(\"query\",newseq$aln.hit.name),],\n                               res.prop = SAPCA$numerical.alignment$res.prop)\n  \n  # Scale new sequnce using same scaling as SAPCA (gaps as \"NA\")\n  newseq.scale.stack <- NULL\n  for (x in 1:length(res.props)) {\n    newseq.scale.stack[[res.props[x]]] <- (newseq.num$MSA.num.stack[[res.props[x]]]- prop.means[x]) /\n      sqrt(prop.vars[x])\n  }\n  \n  # Reflow into single wide matrix\n  newseq.scale.wide <- newseq.scale.stack[[1]]\n  for (x in 2:length(res.props)) {\n    newseq.scale.wide <- cbind(newseq.scale.wide, newseq.scale.stack[[res.props[x]]])\n  }\n  \n  # Replace gaps (currently \"NA\") with column average of the scaled SAPCA\n  # Create na.colmean function\n  gapvalues  <- colMeans(SAPCA$numerical.alignment$MSA.scale.wide)\n  na.replace <- function(x,y){\n    x[is.na(x)] <- y\n    x\n  }\n  newseq.scale.wide.g <- NULL\n  for(i in 1:ncol(newseq.scale.wide)){\n    newseq.scale.wide.g <- cbind(newseq.scale.wide.g,\n                                 na.replace(newseq.scale.wide[,i],gapvalues[i]))\n  }\n  \n  # Rotate scaled sequence into same space as SAPCA\n  newseq.rot <- scale(newseq.scale.wide.g,\n                      SAPCA$seq.space.PCA$centre,\n                      SAPCA$seq.space.PCA$scale) %*% SAPCA$seq.space.PCA$loadings\n  \n  # Output\n  output <- list(seq       = newseq,\n                 seq.num   = newseq.num$MSA.num.wide,\n                 seq.scale = newseq.scale.wide.g,\n                 seq.rot   = newseq.rot)\n  output\n}\n\n\n\nseq.clust.add <- function(SAPCA,newseq.r){\n  \n  SAPCA.c  <- mclustrev(SAPCA)\n  newseq.c <- mclust::predict.Mclust(SAPCA.c,newseq.r$seq.rot[,SAPCA$call$clusterPCs])\n  newseq.c\n}\n\n\n\nmclustrev <- function(SAPCA){\n  output <- SAPCA$seq.space.clusters$other\n  \n  output$classification <- SAPCA$seq.space.clusters$classification\n  output$G              <- SAPCA$seq.space.clusters$optimal\n  output$z              <- SAPCA$seq.space.clusters$likelihoods\n  \n  class(output) <- \"Mclust\"\n  output\n}\n\n\n\nseq.SAPCA.add <- function (SAPCA,newseq.r,newseq.c){\n  output <- SAPCA\n  output$numerical.alignment$seq.names      <- rownames(newseq.r$seq$MSA)  \n  output$numerical.alignment$MSA            <- newseq.r$seq$MSA\n  output$numerical.alignment$MSA.num.wide   <- rbind(newseq.r$seq.num[1,],\n                                                     SAPCA$numerical.alignment$MSA.num.wide)\n  output$numerical.alignment$MSA.scale.wide <- rbind(newseq.r$seq.scale[1,],\n                                                     SAPCA$numerical.alignment$MSA.scale.wide)\n  output$numerical.alignment$MSA.num.stack  <- NULL\n  output$numerical.alignment$MSA.scale.stack<- NULL\n\n  output$seq.space.PCA$coordinates          <- rbind(newseq.r$seq.rot[1,],\n                                                     SAPCA$seq.space.PCA$coordinates)\n  output$seq.space.clusters$likelihoods     <- rbind(newseq.c$z[1,],\n                                                     SAPCA$seq.space.clusters$likelihoods)\n  output$seq.space.clusters$classification  <- c(newseq.c$classification[1],\n                                                 SAPCA$seq.space.clusters$classification)\n  \n  rownames(output$numerical.alignment$MSA.num.wide)[1]   <- \"query\"\n  rownames(output$numerical.alignment$MSA.scale.wide)[1] <- \"query\"\n  rownames(output$seq.space.PCA$coordinates)[1]          <- \"query\"\n  rownames(output$seq.space.clusters$likelihoods)[1]     <- \"query\"\n  \n  output\n}\n\n\n\nseq.add.full <- function (SAPCA,sequence,SAPCAname=NULL){\n  \n  newseq   <- seq.MSA.add(SAPCA,sequence,SAPCAname)\n  newseq.r <- seq.rotate(SAPCA,newseq)\n  newseq.c <- seq.clust.add(SAPCA,newseq.r)\n  SAPCA2   <- seq.SAPCA.add(SAPCA,newseq.r,newseq.c)\n  \n  SAPCA2\n}\n\n\n\n#BLOSUM40\nblosum <- function(file=\"C:\\\\Users\\\\T\\\\OneDrive\\\\0-Sequences\\\\2-PCA\\\\0-Raw data and scalers\\\\0 - BLOSUM40.csv\"){\n  BLOSUM40 <- read.csv(file)\n  BLOSUM40.names <- BLOSUM40[,1]\n  BLOSUM40 <- BLOSUM40[,-1]\n  BLOSUM40 <- as.matrix(BLOSUM40)\n  rownames(BLOSUM40)<-BLOSUM40.names\n  colnames(BLOSUM40)<-BLOSUM40.names\n  BLOSUM40  \n}\n\n\n\npercent <- function(x, digits = 1, format = \"f\", ...) {\n  paste0(formatC(100 * x, format = format, digits = digits, ...), \"%\")\n}\n\n\n",
    "created" : 1491287617333.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4270993096",
    "id" : "AEF216A3",
    "lastKnownWriteTime" : 1491284020,
    "last_content_update" : 1491284020,
    "path" : "C:/Users/T/OneDrive/1-Scripts/GitHub/DefSpace/R/DefSpace functions.R",
    "project_path" : "R/DefSpace functions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}